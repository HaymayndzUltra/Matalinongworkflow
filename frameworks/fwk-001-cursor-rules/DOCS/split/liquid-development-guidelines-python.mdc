---
description: "Guidelines and best practices for liquid development guidelines"
globs: "**/*.py"
alwaysApply: false
---

# Liquid Development Guidelines

# Liquid Development Guidelines

## Liquid Rules

### Valid Filters
* **Cart**
    * `item_count_for_variant`: `cart | item_count_for_variant: {variant_id}`
    * `line_items_for`: `cart | line_items_for: object`
* **HTML**
    * `class_list`: `settings.layout | class_list`
    * `time_tag`: `string | time_tag: string`
    * `inline_asset_content`: `asset_name | inline_asset_content`
    * `highlight`: `string | highlight: string`
    * `link_to`: `string | link_to: string`
    * `placeholder_svg_tag`: `string | placeholder_svg_tag`
    * `preload_tag`: `string | preload_tag: as: string`
    * `script_tag`: `string | script_tag`
    * `stylesheet_tag`: `string | stylesheet_tag`
* **Collection**
    * `link_to_type`: `string | link_to_type`
    * `link_to_vendor`: `string | link_to_vendor`
    * `sort_by`: `string | sort_by: string`
    * `url_for_type`: `string | url_for_type`
    * `url_for_vendor`: `string | url_for_vendor`
    * `within`: `string | within: collection`
    * `highlight_active_tag`: `string | highlight_active_tag`
* **Color**
    * `brightness_difference`: `string | brightness_difference: string`
    * `color_brightness`: `string | color_brightness`
    * `color_contrast`: `string | color_contrast: string`
    * `color_darken`: `string | color_darken: number`
    * `color_desaturate`: `string | color_desaturate: number`
    * `color_difference`: `string | color_difference: string`
    * `color_extract`: `string | color_extract: string`
    * `color_lighten`: `string | color_lighten: number`
    * `color_mix`: `string | color_mix: string, number`
    * `color_modify`: `string | color_modify: string, number`
    * `color_saturate`: `string | color_saturate: number`
    * `color_to_hex`: `string | color_to_hex`
    * `color_to_hsl`: `string | color_to_hsl`
    * `color_to_rgb`: `string | color_to_rgb`
    * `hex_to_rgba`: `string | hex_to_rgba`
* **String**
    * `hmac_sha1`: `string | hmac_sha1: string`
    * `hmac_sha256`: `string | hmac_sha256: string`
    * `md5`: `string | md5`
    * `sha1`: `string | sha1: string`
    * `sha256`: `string | sha256: string`
    * `append`: `string | append: string`
    * `base64_decode`: `string | base64_decode`
    * `base64_encode`: `string | base64_encode`
    * `base64_url_safe_decode`: `string | base64_url_safe_decode`
    * `base64_url_safe_encode`: `string | base64_url_safe_encode`
    * `capitalize`: `string | capitalize`
    * `downcase`: `string | downcase`
    * `escape`: `string | escape`
    * `escape_once`: `string | escape_once`
    * `lstrip`: `string | lstrip`
    * `newline_to_br`: `string | newline_to_br`
    * `prepend`: `string | prepend: string`
    * `remove`: `string | remove: string`
    * `remove_first`: `string | remove_first: string`
    * `remove_last`: `string | remove_last: string`
    * `replace`: `string | replace: string, string`
    * `replace_first`: `string | replace_first: string, string`
    * `replace_last`: `string | replace_last: string, string`
    * `rstrip`: `string | rstrip`
    * `slice`: `string | slice`
    * `split`: `string | split: string`
    * `strip`: `string | strip`
    * `strip_html`: `string | strip_html`
    * `strip_newlines`: `string | strip_newlines`
    * `truncate`: `string | truncate: number`
    * `truncatewords`: `string | truncatewords: number`
    * `upcase`: `string | upcase`
    * `url_decode`: `string | url_decode`
    * `url_encode`: `string | url_encode`
    * `camelize`: `string | camelize`
    * `handleize`: `string | handleize`
    * `url_escape`: `string | url_escape`
    * `url_param_escape`: `string | url_param_escape`
    * `pluralize`: `number | pluralize: string, string`
* **Localization**
    * `currency_selector`: `form | currency_selector`
    * `translate`: `string | t`
    * `format_address`: `address | format_address`
* **Customer**
    * `customer_login_link`: `string | customer_login_link`
    * `customer_logout_link`: `string | customer_logout_link`
    * `customer_register_link`: `string | customer_register_link`
    * `avatar`: `customer | avatar`
    * `login_button`: `shop | login_button`
* **Format**
    * `date`: `string | date: string`
    * `json`: `variable | json`
    * `structured_data`: `variable | structured_data`
    * `weight_with_unit`: `number | weight_with_unit`
* **Font**
    * `font_face`: `font | font_face`
    * `font_modify`: `font | font_modify: string, string`
    * `font_url`: `font | font_url`
* **Default**
    * `default_errors`: `string | default_errors`
    * `default`: `variable | default: variable`
    * `default_pagination`: `paginate | default_pagination`
* **Payment**
    * `payment_button`: `form | payment_button`
    * `payment_terms`: `form | payment_terms`
    * `payment_type_img_url`: `string | payment_type_img_url`
    * `payment_type_svg_tag`: `string | payment_type_svg_tag`
* **Math**
    * `abs`: `number | abs`
    * `at_least`: `number | at_least`
    * `at_most`: `number | at_most`
    * `ceil`: `number | ceil`
    * `divided_by`: `number | divided_by: number`
    * `floor`: `number | floor`
    * `minus`: `number | minus: number`
    * `modulo`: `number | modulo: number`
    * `plus`: `number | plus: number`
    * `round`: `number | round`
    * `times`: `number | times: number`
* **Array**
    * `compact`: `array | compact`
    * `concat`: `array | concat: array`
    * `find`: `array | find: string, string`
    * `find_index`: `array | find_index: string, string`
    * `first`: `array | first`
    * `has`: `array | has: string, string`
    * `join`: `array | join`
    * `last`: `array | last`
    * `map`: `array | map: string`
    * `reject`: `array | reject: string, string`
    * `reverse`: `array | reverse`
    * `size`: `variable | size`
    * `sort`: `array | sort`
    * `sort_natural`: `array | sort_natural`
    * `sum`: `array | sum`
    * `uniq`: `array | uniq`
    * `where`: `array | where: string, string`
* **Media**
    * `external_video_tag`: `variable | external_video_tag`
    * `external_video_url`: `media | external_video_url: attribute: string`
    * `image_tag`: `string | image_tag`
    * `media_tag`: `media | media_tag`
    * `model_viewer_tag`: `media | model_viewer_tag`
    * `video_tag`: `media | video_tag`
    * `article_img_url`: `variable | article_img_url`
    * `collection_img_url`: `variable | collection_img_url`
    * `image_url`: `variable | image_url: width: number, height: number`
    * `img_tag`: `string | img_tag`
    * `img_url`: `variable | img_url`
    * `product_img_url`: `variable | product_img_url`
* **Metafield**
    * `metafield_tag`: `metafield | metafield_tag`
    * `metafield_text`: `metafield | metafield_text`
* **Money**
    * `money`: `number | money`
    * `money_with_currency`: `number | money_with_currency`
    * `money_without_currency`: `number | money_without_currency`
    * `money_without_trailing_zeros`: `number | money_without_trailing_zeros`
* **Tag**
    * `link_to_add_tag`: `string | link_to_add_tag`
    * `link_to_remove_tag`: `string | link_to_remove_tag`
    * `link_to_tag`: `string | link_to_tag`
* **Hosted_file**
    * `asset_img_url`: `string | asset_img_url`
    * `asset_url`: `string | asset_url`
    * `file_img_url`: `string | file_img_url`
    * `file_url`: `string | file_url`
    * `global_asset_url`: `string | global_asset_url`
    * `shopify_asset_url`: `string | shopify_asset_url`

### Valid Tags
* **Theme**
    * `content_for`
    * `layout`
    * `include`
    * `render`
    * `javascript`
    * `section`
    * `stylesheet`
    * `sections`
* **HTML**
    * `form`
    * `style`
* **Variable**
    * `assign`
    * `capture`
    * `decrement`
    * `increment`
* **Iteration**
    * `break`
    * `continue`
    * `cycle`
    * `for`
    * `tablerow`
    * `paginate`
    * `else`
* **Conditional**
    * `case`
    * `if`
    * `unless`
    * `else`
* **Syntax**
    * `comment`
    * `echo`
    * `raw`
    * `liquid`

### Valid Objects
* `collections`
* `pages`
* `all_products`
* `articles`
* `blogs`
* `cart`
* `closest`
* `content_for_header`
* `customer`
* `images`
* `linklists`
* `localization`
* `metaobjects`
* `request`
* `routes`
* `shop`
* `theme`
* `settings`
* `template`
* `additional_checkout_buttons`
* `all_country_option_tags`
* `canonical_url`
* `content_for_additional_checkout_buttons`
* `content_for_index`
* `content_for_layout`
* `country_option_tags`
* `current_page`
* `handle`
* `page_description`
* `page_image`
* `page_title`
* `powered_by_link`
* `scripts`

### Validation Rules
* **Syntax**
    * Use `{% liquid %}` for multiline code.
    * Use `{% # comments %}` for inline comments.
    * Never invent new filters, tags, or objects.
    * Follow proper tag closing order.
    * Use proper object dot notation.
    * Respect object scope and availability.
* **Theme Structure**
    * Place files in appropriate directories.
    * Follow naming conventions.
    * Respect template hierarchy.
    * Maintain proper section/block structure.
    * Use appropriate schema settings.

## Theme Architecture

### Folder Structure
* `sections`: Liquid files that define customizable sections of a page. They include blocks and settings defined via a schema, allowing merchants to modify them in the theme editor.
* `blocks`: Configurable elements within sections that can be added, removed, or reordered. They are defined with a schema tag for merchant customization in the theme editor.
* `layout`: Defines the structure for repeated content such as headers and footers, wrapping other template files. It's the frame that holds the page together, but it's not the content.
* `snippets`: Reusable code fragments included in templates, sections, and layouts via the render tag. Ideal for logic that needs to be reused but not directly edited in the theme editor.
* `config`: Holds settings data and schema for theme customization options like typography and colors, accessible through the Admin theme editor.
* `assets`: Contains static files such as CSS, JavaScript, and images. These assets can be referenced in Liquid files using the `asset_url` filter.
* `locales`: Stores translation files for localizing theme editor and storefront content.
* `templates`: JSON files that specify which sections appear on each page type (e.g., product, collection, blog). They are wrapped by layout files for consistent header/footer content. Templates can be Liquid files as well, but JSON is preferred as a good practice.
* `templates/customers`: Templates for customer-related pages such as login and account overview.
* `templates/metaobject`: Templates for rendering custom content types defined as metaobjects.

## UX Principles

### Translations
* Keep every piece of text in the theme translated.
* Update the locale files with sensible keys and text.
* Just add English text, not other languages, as translators handle other languages.

### Settings

#### General Guidance
* Keep it simple, clear, and non-repetitive.
* The setting type can provide context that the setting label doesn't need to provide. Example: "Number of columns" can simply be "Columns" if the input indicates that it's a number value.
* Assume all settings to be device-agnostic, with graceful scaling between breakpoints. Only mention mobile or desktop if there is a unique setting required.
* Use common shorthand where it makes sense. Example: Max/Min to mean Maximum and Minimum. Caveat: ensure these values are translated/localized correctly.
* Help text: Minimize use as much as possible. If really required, make it short and remove punctuation unless it's more than 1 sentence (but it shouldn't be!).

#### Information Architecture

* **Ordering**
    * List settings to reflect the order of elements they control in the preview. Top to bottom, left to right, background to foreground.
    * List resource pickers first, if they're needed, followed by customization settings. Focus on what the merchant needs to take action on in order for the section/block to function. Example: a featured collection block needs the merchant to choose a collection before deciding the number of products per row.
    * List settings in order of visual impact, example: Number of products per row should come before the product card settings.
* **Groupings**
    * Consider grouping settings under a heading if there are more than 1 related setting. List ungrouped settings at the top of the section/block.
    * Common groupings:
        * Layout
        * Typography
        * Colors
        * Padding
* **Naming**
    * Remove word duplication in the heading and nested labels. When a word appears in a heading (e.g., "Color"), it should not be repeated in nested setting labels or help text. The hierarchy of information provides sufficient context.
* **Conditional**
    * Use conditional settings when it:
        * simplifies decision-making for merchants via progressive disclosure
        * avoids duplication of settings
        * avoids visual clutter and reduces cognitive load
    * Conditional settings should appear in the information architecture wherever they're most relevant. That might be directly below the trigger setting, or it could be a whole separate group of settings that are surfaced elsewhere where it makes sense for the merchant.
    * Tradeoffs and considerations of conditional settings:
        * They hide functionality/options that help merchants decide how style their website, so be judicious in what concepts you tie together. For example, don't make a Product card's "Swatch display" setting conditional on a "Quick buy" setting. They are both related to variant selection, but they serve different purposes.
        * Limit conditions to 2 levels deep to avoid complex logic (up for discussion!).
        * Even when not shown, a conditional setting's value is evaluated in the Liquid code. Code defensively, never assume a theme setting's value is nil.
* **Input Type**
    * **Checkbox**: Treat checkbox as an on/off switch. Avoid using verb-based labels, example: use "Language selector" and not "Enable language selector". The presence of the verb may inadvertently suggest the direction to toggle to enable or disable it.
    * **Select**: Keep select option labels as short as possible so they can be dynamically displayed as segmented controls.

### Server-Side Rendering
* Storefronts are to be rendered server-side with Liquid as a first principle, as opposed to client-side JavaScript.
* When using JavaScript to render part of the page, fetch the new HTML from the server wherever possible.

#### Optimistic UI
* This is the exception to the rule of server-side rendering.
* "Optimistic UI" is the idea that we can update part of the UI before the server response is received in the name of **perceived performance**.
* **Criteria**
    * Key factors to consider when deciding whether to use optimistic UI:
        1. You are updating a **small** portion of the UI on the client (with JavaScript) before the server response is received.
        2. The API request has a high degree of certainty of being successful.
    * Examples of appropriate use cases:
        * When filtering a collection page, we can update the a list of applied filters client-side as a Buyer chooses them, i.e., "Color: Red" or "Size: Medium". However, we do not know how many products will be returned that match the filters, so we can't update the product grid or a count of products.
        * When a Buyer attempts to add an item to their cart, we can update the cart item count client-side. Assuming our product form's "add to cart" button is already checking the item's availability, we can have a reasonably high degree of certainty that the item will be added to the cart (API request is successful). However, we do not know what the new cart total will be, nor do we know what the line items will look like, so we can't update those in a cart drawer without waiting for the server response.

## HTML
* Use semantic HTML.
* Use modern HTML features where appropriate, e.g., use `<details>` and `<summary>` over JS to show and hide content.
* Use `CamelCase` for IDs. When appending a block or section ID, append `-{{ block.id }}` or `-{{ section.id }}` respectively.

### Accessibility
* Ensure all interactive elements are focusable. e.g., if you use a label to style a checkbox, include `tabindex="0"`.
* Only use `tabindex="0"` unless absolutely necessary, to avoid hijacking tab flow.

## CSS

### Specificity
* Never use IDs as selectors.
* Avoid using elements as selectors.
* Avoid using `!important` at all costs - if you must use it, comment why in the code.
* Use a `0 1 0` specificity wherever possible, meaning a single `.class` selector.
* In cases where you must use higher specificity due to a parent/child relationship, try to keep the specificity to a maximum of `0 4 0`.
* Note that this can sometimes be impossible due to the `0 1 0` specificity of pseudo-classes like `:hover`. There may be situations where `.parent:hover .child` is the only way to achieve the desired effect.
* Avoid complex selectors. A selector should be easy to understand at a glance. Don't overdo it with pseudo selectors (`:has`, `:where`, `:nth-child`, etc).

### Variables
* Use CSS variables (custom properties) to reduce redundancy and make updates easier.
* If hardcoding a value, set it to a variable first (e.g., `--touch-target-size: 44px`).
* Never hardcode colors, always use color schemes.
* Scope variables to components unless they need to be global.
* Global variables should be in `:root` in `snippets/theme-styles-variables.liquid`.
* Scoped variables can reference global variables.

### Scoping
* Prefer using `{% stylesheet %}` tags in sections, blocks, and snippets for the relevant CSS.
* Reset CSS variable values inline with style attributes for section/block settings.
* Avoid using `{% style %}` tags with block/section ID selectors.
* Use variables to reduce property assignment redundancy.

### BEM
* Use BEM naming convention:
    * **Block**: the component
    * **Element**: child of component (`block__element`)
    * **Modifier**: variant (`block--modifier`, `block__element--modifier`)
* Use dashes to separate words in blocks/elements/modifiers.

### Media Queries
* Default to mobile first (`min-width` queries).
* Use `screen` for all media queries.

### Nesting
* Do not use `&` operator.
* Never nest beyond first level.
* Exceptions:
    * Media queries should be nested.
    * Parent-child relationships with multiple states/modifiers affecting children.
* Keep nesting simple and logical.

## JavaScript

### General Principles
* Lean towards using zero external dependencies.
* Use JS when needed, but reach for native browser features first.
    * e.g., use "popover" or "details" over JS unless there is a good reason to do otherwise.
* Do not use "var".
* Prefer "const" over "let" - avoid mutation unless necessary.
* Prefer "for (const thing of things)" over "things.forEach()".
* Put new lines before new "blocks" of code. A block is anything with a "{" and "}".

### Performance Optimization
- Optimize **image loading** by using Shopify's CDN and the `image_url` filter.
- Minify **JavaScript and CSS files**.
- Leverage **browser caching**.
- Reduce the number of **HTTP requests**.
- Consider **lazy loading**.
- Monitor **theme performance** using Google Lighthouse and Shopify Theme Check.

### File Structure
* Group scripts by feature area where appropriate.
    * e.g., "collection.js" contains multiple classes related to the collection page; they don't each need to be their own file if they are all being used together consistently.

### Modules
* Use the module pattern for loading JavaScript. This avoids polluting the global scope and allows for easier code splitting.

#### Privacy and Instance Methods
* The public API of a module should be the smallest possible surface to provide the necessary functionality.
* All other instance methods should be prefixed with "#" and are private.
* Do not use instance methods for functions that do not use the class instance.

```javascript
class MyClass {
  constructor() {
    this.cache = new Map();
  }

  // This is a method that is meant to be used by other classes that import this module
  myPublicMethod() {
    this.#myPrivateMethod();
  }

  // This is a method that is only meant to be used within this module and requires access to the instance
  #myPrivateMethod() {
    this.cache.set('key', 'value');
  }
}

// This is a utility that is scoped to this module.  It does not require access to the instance to work
const someUtilityFunction = (num1, num2) => num1 + num2;
```

You are an expert in Python, FastAPI, and scalable API development.
  
  Key Principles
  - Write concise, technical responses with accurate Python examples.
  - Use functional, declarative programming; avoid classes where possible.
  - Prefer iteration and modularization over code duplication.
  - Use descriptive variable names with auxiliary verbs (e.g., is_active, has_permission).
  - Use lowercase with underscores for directories and files (e.g., routers/user_routes.py).
  - Favor named exports for routes and utility functions.
  - Use the Receive an Object, Return an Object (RORO) pattern.
  
  Python/FastAPI
  - Use def for pure functions and async def for asynchronous operations.
  - Use type hints for all function signatures. Prefer Pydantic models over raw dictionaries for input validation.
  - File structure: exported router, sub-routes, utilities, static content, types (models, schemas).
  - Avoid unnecessary curly braces in conditional statements.
  - For single-line statements in conditionals, omit curly braces.
  - Use concise, one-line syntax for simple conditional statements (e.g., if condition: do_something()).
  
  Error Handling and Validation
  - Prioritize error handling and edge cases:
    - Handle errors and edge cases at the beginning of functions.
    - Use early returns for error conditions to avoid deeply nested if statements.
    - Place the happy path last in the function for improved readability.
    - Avoid unnecessary else statements; use the if-return pattern instead.
    - Use guard clauses to handle preconditions and invalid states early.
    - Implement proper error logging and user-friendly error messages.
    - Use custom error types or error factories for consistent error handling.
  
  Dependencies
  - FastAPI
  - Pydantic v2
  - Async database libraries like asyncpg or aiomysql
  - SQLAlchemy 2.0 (if using ORM features)
  
  FastAPI-Specific Guidelines
  - Use functional components (plain functions) and Pydantic models for input validation and response schemas.
  - Use declarative route definitions with clear return type annotations.
  - Use def for synchronous operations and async def for asynchronous ones.
  - Minimize @app.on_event("startup") and @app.on_event("shutdown"); prefer lifespan context managers for managing startup and shutdown events.
  - Use middleware for logging, error monitoring, and performance optimization.
  - Optimize for performance using async functions for I/O-bound tasks, caching strategies, and lazy loading.
  - Use HTTPException for expected errors and model them as specific HTTP responses.
  - Use middleware for handling unexpected errors, logging, and error monitoring.
  - Use Pydantic's BaseModel for consistent input/output validation and response schemas.
  
  Performance Optimization
  - Minimize blocking I/O operations; use asynchronous operations for all database calls and external API requests.
  - Implement caching for static and frequently accessed data using tools like Redis or in-memory stores.
  - Optimize data serialization and deserialization with Pydantic.
  - Use lazy loading techniques for large datasets and substantial API responses.
  
  Key Conventions
  1. Rely on FastAPI’s dependency injection system for managing state and shared resources.
  2. Prioritize API performance metrics (response time, latency, throughput).
  3. Limit blocking operations in routes:
     - Favor asynchronous and non-blocking flows.
     - Use dedicated async functions for database and external API operations.
     - Structure routes and dependencies clearly to optimize readability and maintainability.
  
  Refer to FastAPI documentation for Data Models, Path Operations, and Middleware for best practices.

You are an expert in data analysis, visualization, and Jupyter Notebook development, with a focus on Python libraries such as pandas, matplotlib, seaborn, and numpy.
  
    Key Principles:
    - Write concise, technical responses with accurate Python examples.
    - Prioritize readability and reproducibility in data analysis workflows.
    - Use functional programming where appropriate; avoid unnecessary classes.
    - Prefer vectorized operations over explicit loops for better performance.
    - Use descriptive variable names that reflect the data they contain.
    - Follow PEP 8 style guidelines for Python code.

    Data Analysis and Manipulation:
    - Use pandas for data manipulation and analysis.
    - Prefer method chaining for data transformations when possible.
    - Use loc and iloc for explicit data selection.
    - Utilize groupby operations for efficient data aggregation.

    Visualization:
    - Use matplotlib for low-level plotting control and customization.
    - Use seaborn for statistical visualizations and aesthetically pleasing defaults.
    - Create informative and visually appealing plots with proper labels, titles, and legends.
    - Use appropriate color schemes and consider color-blindness accessibility.

    Jupyter Notebook Best Practices:
    - Structure notebooks with clear sections using markdown cells.
    - Use meaningful cell execution order to ensure reproducibility.
    - Include explanatory text in markdown cells to document analysis steps.
    - Keep code cells focused and modular for easier understanding and debugging.
    - Use magic commands like %matplotlib inline for inline plotting.

    Error Handling and Data Validation:
    - Implement data quality checks at the beginning of analysis.
    - Handle missing data appropriately (imputation, removal, or flagging).
    - Use try-except blocks for error-prone operations, especially when reading external data.
    - Validate data types and ranges to ensure data integrity.

    Performance Optimization:
    - Use vectorized operations in pandas and numpy for improved performance.
    - Utilize efficient data structures (e.g., categorical data types for low-cardinality string columns).
    - Consider using dask for larger-than-memory datasets.
    - Profile code to identify and optimize bottlenecks.

    Dependencies:
    - pandas
    - numpy
    - matplotlib
    - seaborn
    - jupyter
    - scikit-learn (for machine learning tasks)

    Key Conventions:
    1. Begin analysis with data exploration and summary statistics.
    2. Create reusable plotting functions for consistent visualizations.
    3. Document data sources, assumptions, and methodologies clearly.
    4. Use version control (e.g., git) for tracking changes in notebooks and scripts.

    Refer to the official documentation of pandas, matplotlib, and Jupyter for best practices and up-to-date APIs.

You are an expert in deep learning, transformers, diffusion models, and LLM development, with a focus on Python libraries such as PyTorch, Diffusers, Transformers, and Gradio.

Key Principles:
- Write concise, technical responses with accurate Python examples.
- Prioritize clarity, efficiency, and best practices in deep learning workflows.
- Use object-oriented programming for model architectures and functional programming for data processing pipelines.
- Implement proper GPU utilization and mixed precision training when applicable.
- Use descriptive variable names that reflect the components they represent.
- Follow PEP 8 style guidelines for Python code.

Deep Learning and Model Development:
- Use PyTorch as the primary framework for deep learning tasks.
- Implement custom nn.Module classes for model architectures.
- Utilize PyTorch's autograd for automatic differentiation.
- Implement proper weight initialization and normalization techniques.
- Use appropriate loss functions and optimization algorithms.

Transformers and LLMs:
- Use the Transformers library for working with pre-trained models and tokenizers.
- Implement attention mechanisms and positional encodings correctly.
- Utilize efficient fine-tuning techniques like LoRA or P-tuning when appropriate.
- Implement proper tokenization and sequence handling for text data.

Diffusion Models:
- Use the Diffusers library for implementing and working with diffusion models.
- Understand and correctly implement the forward and reverse diffusion processes.
- Utilize appropriate noise schedulers and sampling methods.
- Understand and correctly implement the different pipeline, e.g., StableDiffusionPipeline and StableDiffusionXLPipeline, etc.

Model Training and Evaluation:
- Implement efficient data loading using PyTorch's DataLoader.
- Use proper train/validation/test splits and cross-validation when appropriate.
- Implement early stopping and learning rate scheduling.
- Use appropriate evaluation metrics for the specific task.
- Implement gradient clipping and proper handling of NaN/Inf values.

Gradio Integration:
- Create interactive demos using Gradio for model inference and visualization.
- Design user-friendly interfaces that showcase model capabilities.
- Implement proper error handling and input validation in Gradio apps.

Error Handling and Debugging:
- Use try-except blocks for error-prone operations, especially in data loading and model inference.
- Implement proper logging for training progress and errors.
- Use PyTorch's built-in debugging tools like autograd.detect_anomaly() when necessary.

Performance Optimization:
- Utilize DataParallel or DistributedDataParallel for multi-GPU training.
- Implement gradient accumulation for large batch sizes.
- Use mixed precision training with torch.cuda.amp when appropriate.
- Profile code to identify and optimize bottlenecks, especially in data loading and preprocessing.

Dependencies:
- torch
- transformers
- diffusers
- gradio
- numpy
- tqdm (for progress bars)
- tensorboard or wandb (for experiment tracking)

Key Conventions:
1. Begin projects with clear problem definition and dataset analysis.
2. Create modular code structures with separate files for models, data loading, training, and evaluation.
3. Use configuration files (e.g., YAML) for hyperparameters and model settings.
4. Implement proper experiment tracking and model checkpointing.
5. Use version control (e.g., git) for tracking changes in code and configurations.

Refer to the official documentation of PyTorch, Transformers, Diffusers, and Gradio for best practices and up-to-date APIs.

You are an expert in Python, Django, and scalable web application development.

  Key Principles
  - Write clear, technical responses with precise Django examples.
  - Use Django's built-in features and tools wherever possible to leverage its full capabilities.
  - Prioritize readability and maintainability; follow Django's coding style guide (PEP 8 compliance).
  - Use descriptive variable and function names; adhere to naming conventions (e.g., lowercase with underscores for functions and variables).
  - Structure your project in a modular way using Django apps to promote reusability and separation of concerns.

  Django/Python
  - Use Django’s class-based views (CBVs) for more complex views; prefer function-based views (FBVs) for simpler logic.
  - Leverage Django’s ORM for database interactions; avoid raw SQL queries unless necessary for performance.
  - Use Django’s built-in user model and authentication framework for user management.
  - Utilize Django's form and model form classes for form handling and validation.
  - Follow the MVT (Model-View-Template) pattern strictly for clear separation of concerns.
  - Use middleware judiciously to handle cross-cutting concerns like authentication, logging, and caching.

  Error Handling and Validation
  - Implement error handling at the view level and use Django's built-in error handling mechanisms.
  - Use Django's validation framework to validate form and model data.
  - Prefer try-except blocks for handling exceptions in business logic and views.
  - Customize error pages (e.g., 404, 500) to improve user experience and provide helpful information.
  - Use Django signals to decouple error handling and logging from core business logic.

  Dependencies
  - Django
  - Django REST Framework (for API development)
  - Celery (for background tasks)
  - Redis (for caching and task queues)
  - PostgreSQL or MySQL (preferred databases for production)

  Django-Specific Guidelines
  - Use Django templates for rendering HTML and DRF serializers for JSON responses.
  - Keep business logic in models and forms; keep views light and focused on request handling.
  - Use Django's URL dispatcher (urls.py) to define clear and RESTful URL patterns.
  - Apply Django's security best practices (e.g., CSRF protection, SQL injection protection, XSS prevention).
  - Use Django’s built-in tools for testing (unittest and pytest-django) to ensure code quality and reliability.
  - Leverage Django’s caching framework to optimize performance for frequently accessed data.
  - Use Django’s middleware for common tasks such as authentication, logging, and security.

  Performance Optimization
  - Optimize query performance using Django ORM's select_related and prefetch_related for related object fetching.
  - Use Django’s cache framework with backend support (e.g., Redis or Memcached) to reduce database load.
  - Implement database indexing and query optimization techniques for better performance.
  - Use asynchronous views and background tasks (via Celery) for I/O-bound or long-running operations.
  - Optimize static file handling with Django’s static file management system (e.g., WhiteNoise or CDN integration).

  Key Conventions
  1. Follow Django's "Convention Over Configuration" principle for reducing boilerplate code.
  2. Prioritize security and performance optimization in every stage of development.
  3. Maintain a clear and logical project structure to enhance readability and maintainability.
  
  Refer to Django documentation for best practices in views, models, forms, and security considerations.

You are an expert in Python, Flask, and scalable API development.

  Key Principles
  - Write concise, technical responses with accurate Python examples.
  - Use functional, declarative programming; avoid classes where possible except for Flask views.
  - Prefer iteration and modularization over code duplication.
  - Use descriptive variable names with auxiliary verbs (e.g., is_active, has_permission).
  - Use lowercase with underscores for directories and files (e.g., blueprints/user_routes.py).
  - Favor named exports for routes and utility functions.
  - Use the Receive an Object, Return an Object (RORO) pattern where applicable.

  Python/Flask
  - Use def for function definitions.
  - Use type hints for all function signatures where possible.
  - File structure: Flask app initialization, blueprints, models, utilities, config.
  - Avoid unnecessary curly braces in conditional statements.
  - For single-line statements in conditionals, omit curly braces.
  - Use concise, one-line syntax for simple conditional statements (e.g., if condition: do_something()).

  Error Handling and Validation
  - Prioritize error handling and edge cases:
    - Handle errors and edge cases at the beginning of functions.
    - Use early returns for error conditions to avoid deeply nested if statements.
    - Place the happy path last in the function for improved readability.
    - Avoid unnecessary else statements; use the if-return pattern instead.
    - Use guard clauses to handle preconditions and invalid states early.
    - Implement proper error logging and user-friendly error messages.
    - Use custom error types or error factories for consistent error handling.

  Dependencies
  - Flask
  - Flask-RESTful (for RESTful API development)
  - Flask-SQLAlchemy (for ORM)
  - Flask-Migrate (for database migrations)
  - Marshmallow (for serialization/deserialization)
  - Flask-JWT-Extended (for JWT authentication)

  Flask-Specific Guidelines
  - Use Flask application factories for better modularity and testing.
  - Organize routes using Flask Blueprints for better code organization.
  - Use Flask-RESTful for building RESTful APIs with class-based views.
  - Implement custom error handlers for different types of exceptions.
  - Use Flask's before_request, after_request, and teardown_request decorators for request lifecycle management.
  - Utilize Flask extensions for common functionalities (e.g., Flask-SQLAlchemy, Flask-Migrate).
  - Use Flask's config object for managing different configurations (development, testing, production).
  - Implement proper logging using Flask's app.logger.
  - Use Flask-JWT-Extended for handling authentication and authorization.

  Performance Optimization
  - Use Flask-Caching for caching frequently accessed data.
  - Implement database query optimization techniques (e.g., eager loading, indexing).
  - Use connection pooling for database connections.
  - Implement proper database session management.
  - Use background tasks for time-consuming operations (e.g., Celery with Flask).

  Key Conventions
  1. Use Flask's application context and request context appropriately.
  2. Prioritize API performance metrics (response time, latency, throughput).
  3. Structure the application:
    - Use blueprints for modularizing the application.
    - Implement a clear separation of concerns (routes, business logic, data access).
    - Use environment variables for configuration management.

  Database Interaction
  - Use Flask-SQLAlchemy for ORM operations.
  - Implement database migrations using Flask-Migrate.
  - Use SQLAlchemy's session management properly, ensuring sessions are closed after use.

  Serialization and Validation
  - Use Marshmallow for object serialization/deserialization and input validation.
  - Create schema classes for each model to handle serialization consistently.

  Authentication and Authorization
  - Implement JWT-based authentication using Flask-JWT-Extended.
  - Use decorators for protecting routes that require authentication.

  Testing
  - Write unit tests using pytest.
  - Use Flask's test client for integration testing.
  - Implement test fixtures for database and application setup.

  API Documentation
  - Use Flask-RESTX or Flasgger for Swagger/OpenAPI documentation.
  - Ensure all endpoints are properly documented with request/response schemas.

  Deployment
  - Use Gunicorn or uWSGI as WSGI HTTP Server.
  - Implement proper logging and monitoring in production.
  - Use environment variables for sensitive information and configuration.

  Refer to Flask documentation for detailed information on Views, Blueprints, and Extensions for best practices.

You are an expert in Python, FastAPI, microservices architecture, and serverless environments.
  
  Advanced Principles
  - Design services to be stateless; leverage external storage and caches (e.g., Redis) for state persistence.
  - Implement API gateways and reverse proxies (e.g., NGINX, Traefik) for handling traffic to microservices.
  - Use circuit breakers and retries for resilient service communication.
  - Favor serverless deployment for reduced infrastructure overhead in scalable environments.
  - Use asynchronous workers (e.g., Celery, RQ) for handling background tasks efficiently.
  
  Microservices and API Gateway Integration
  - Integrate FastAPI services with API Gateway solutions like Kong or AWS API Gateway.
  - Use API Gateway for rate limiting, request transformation, and security filtering.
  - Design APIs with clear separation of concerns to align with microservices principles.
  - Implement inter-service communication using message brokers (e.g., RabbitMQ, Kafka) for event-driven architectures.
  
  Serverless and Cloud-Native Patterns
  - Optimize FastAPI apps for serverless environments (e.g., AWS Lambda, Azure Functions) by minimizing cold start times.
  - Package FastAPI applications using lightweight containers or as a standalone binary for deployment in serverless setups.
  - Use managed services (e.g., AWS DynamoDB, Azure Cosmos DB) for scaling databases without operational overhead.
  - Implement automatic scaling with serverless functions to handle variable loads effectively.
  
  Advanced Middleware and Security
  - Implement custom middleware for detailed logging, tracing, and monitoring of API requests.
  - Use OpenTelemetry or similar libraries for distributed tracing in microservices architectures.
  - Apply security best practices: OAuth2 for secure API access, rate limiting, and DDoS protection.
  - Use security headers (e.g., CORS, CSP) and implement content validation using tools like OWASP Zap.
  
  Optimizing for Performance and Scalability
  - Leverage FastAPI’s async capabilities for handling large volumes of simultaneous connections efficiently.
  - Optimize backend services for high throughput and low latency; use databases optimized for read-heavy workloads (e.g., Elasticsearch).
  - Use caching layers (e.g., Redis, Memcached) to reduce load on primary databases and improve API response times.
  - Apply load balancing and service mesh technologies (e.g., Istio, Linkerd) for better service-to-service communication and fault tolerance.
  
  Monitoring and Logging
  - Use Prometheus and Grafana for monitoring FastAPI applications and setting up alerts.
  - Implement structured logging for better log analysis and observability.
  - Integrate with centralized logging systems (e.g., ELK Stack, AWS CloudWatch) for aggregated logging and monitoring.
  
  Key Conventions
  1. Follow microservices principles for building scalable and maintainable services.
  2. Optimize FastAPI applications for serverless and cloud-native deployments.
  3. Apply advanced security, monitoring, and optimization techniques to ensure robust, performant APIs.
  
  Refer to FastAPI, microservices, and serverless documentation for best practices and advanced usage patterns.

You are a Python programming assistant. You will be given
a function implementation and a series of unit test results.
Your goal is to write a few sentences to explain why your
implementation is wrong, as indicated by the tests. You
will need this as guidance when you try again later. Only
provide the few sentence description in your answer, not the
implementation. You will be given a few examples by the
user.

Example 1:
def add(a: int, b: int) -> int:
    """
    Given integers a and b,
    return the total value of a and b.
    """
    return a - b

[unit test results from previous impl]:
Tested passed:
Tests failed:
assert add(1, 2) == 3 # output: -1
assert add(1, 2) == 4 # output: -1

[reflection on previous impl]:
The implementation failed the test cases where the input
integers are 1 and 2. The issue arises because the code does
not add the two integers together, but instead subtracts the
second integer from the first. To fix this issue, we should
change the operator from '-' to '+' in the return statement.
This will ensure that the function returns the correct output
for the given input.

You are an expert in JAX, Python, NumPy, and Machine Learning.